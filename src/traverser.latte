
var flatten = require("mout/array/flatten"),
	util = require("util");

function traverser(args) {
	var me = {};

	me.context = () => {
		return {
			scopes: [],
			blocks: [],

			enterScope: function (node) {
				var scope = this.enterBlock(node),
					temp = 0;
				scope.temp = function () {
					return "__t" + temp++;
				}
				this.scopes.unshift(scope);
				return scope;
			},
			exitScope: function () {
				this.scopes.shift();
				this.exitBlock();
			},
			scope: function (node, fn) {
				this.enterScope(node);
				try { return fn(this); }
				finally { this.exitScope(); };
			},

			enterBlock: function (node) {
				var block = {
					node: node
				}
				this.blocks.unshift(block);
				return block;
			},
			exitBlock: function () {
				this.blocks.shift();
			},
			block: function (node, fn) {
				this.enterBlock(node);
				try { return fn(this); }
				finally { this.exitBlock(); };
			},

			isBlockScope: function () {
				return this.scopes[0] === this.blocks[0];
			},

			// Allocate a temp in the nearest scope
			temp: function () {
				return this.scopes[0].temp();
			}
		}
	}

	me.traverse = (ast) => {
		var context = me.context();
		context.ast = ast;
		return context.scope(ast, context => {
			ast.body = me.stmts(ast.body, context);
			return ast;
		});
	}

	me.stmts = (stmts, context) => {
		return flatten(stmts.map(stmt => me.stmt(stmt, context)));
	}

	me.stmt = (stmt, context) => {
		if (!stmt) return stmt;
		switch (stmt.type) {
			case 'BlockStatement':
				return me.block(stmt, context);

			case 'VariableDeclaration':
				return me.varDecl(stmt, context);

			case 'FunctionDeclaration':
				return me.funcDecl(stmt, context);

			case 'ExpressionStatement':
		        stmt.expression = me.expr(stmt.expression, context);
		        return stmt;

		    case 'IfStatement': 
		    	return {
		    		type: 'IfStatement',
		    		test: stmt.test && me.expr(stmt.test, context),
		    		consequent: me.stmt(stmt.consequent, context),
		    		alternate: stmt.alternate && me.stmt(stmt.alternate, context)
		    	}

		    case 'ForStatement': 
		    	return {
		    		type: 'ForStatement',
		    		init: stmt.init && me.stmt(stmt.init, context),
		    		test: stmt.test && me.expr(stmt.test, context),
		    		update: stmt.update && me.expr(stmt.update, context),
		    		body: me.stmt(stmt.body, context)
		    	}

		    case 'ForInStatement':
		    	return me.forInStmt(stmt, context)

		    case 'WhileStatement':
		    case 'DoWhileStatement':
		    	stmt.test = me.expr(stmt.test, context)
		    	stmt.body = me.stmt(stmt.body, context)
		    	return stmt

		    case 'SwitchStatement':
		    	stmt.discriminant = me.expr(stmt.discriminant, context);
		    	stmt.cases = stmt.cases.map(c => {
		    		c.consequent = me.stmts(c.consequent, context);
		    		return c;
		    	})
		    	return stmt;

		    case 'ReturnStatement':
		    case 'ThrowStatement':
		    	return {
		    		type: stmt.type,
		    		argument: me.expr(stmt.argument, context)
		    	}

		    case 'TryStatement':
		    	stmt.block = me.stmt(stmt.block, context);
		    	stmt.handlers.forEach(handler => {
		    		handler.body = me.stmt(handler.body, context)
		    	})
		    	stmt.finalizer = stmt.finalizer && me.stmt(stmt.finalizer, context);
		    	return stmt;

		    case 'BreakStatement':
		    case 'EmptyStatement':
		    	break;

		    case undefined:
		    	throw new Error("Fatal: Stmt type is undefined! In: " + util.inspect(stmt));

			default:
				console.log("Unhandled stmt: ", stmt.type);
		}
		return stmt;
	}

	me.block = (stmt, context) => {
		return context.block(stmt, context => {
			stmt.body = me.stmts(stmt.body, context);
			return stmt;
		});
	}

	me.forInStmt = (stmt, context) => {
		stmt.body = me.stmt(stmt.body, context)
		return stmt;
	}

	me.varDecl = (stmt, context) => {
		stmt.declarations = me.decls(stmt.declarations, context);
		return stmt;
	}
	me.decls = (decls, context) => {
		return flatten(decls.map(d => me.decl(d, context)));
	}
	me.decl = (decl, context) => {
		decl.init = me.expr(decl.init, context);
		return decl;
	}
	me.funcDecl = (fn, context) => {
		return me.func(fn, context);
	}
	me.expr = (expr, context) => {
		if (!expr) return expr;
		switch (expr.type) {
			case 'FunctionExpression':
				return me.funcExpr(expr, context);
			case 'ArrowFunctionExpression':
				return me.arrowFuncExpr(expr, context);
			case 'CallExpression':
			case 'NewExpression':
				return {
					type: expr.type,
					callee: me.expr(expr.callee, context),
					arguments: expr.arguments.map(arg => me.expr(arg, context))
				}
			case 'ObjectExpression':
				return {
					type: 'ObjectExpression',
					properties: expr.properties.map(p => {
						p.value = me.expr(p.value, context);
						return p;
					})
				}
			case 'ArrayExpression':
				expr.elements = expr.elements.map(e => me.expr(e, context))
				return expr;
			case 'ComprehensionExpression':
				return me.comprehension(expr, context);
			case 'MemberExpression':
				expr.object = me.expr(expr.object, context);
				expr.property = me.expr(expr.property, context);
				return expr;
			case 'AssignmentExpression':
		        expr.right = me.expr(expr.right, context);
		        return expr;
		    case 'ConditionalExpression':
		    	return me.conditional(expr, context);
		    case 'BinaryExpression':
		    case 'LogicalExpression':
		    	return me.binary(expr, context);
		    case 'UnaryExpression':
		    case 'UpdateExpression':
		    	return me.unary(expr, context);
		    case 'MonadExpression':
		    	return me.monad(expr, context);
		    case 'Identifier':
		    	return me.ident(expr, context);
		    case 'ThisExpression':
		    	return me.thisExpr(expr, context);
		    case 'TemplateLiteral':
		    	return me.quasiLiteral(expr, context);
		    case 'Literal':
		    	break;
			default:
				console.log("Unhandled expr: ", expr.type);
		}
		return expr;
	}
	
	me.arrowFuncExpr = (fn, context) => {
		fn.body = fn.body.type == 'BlockStatement'
			? me.stmt(fn.body, context) : me.expr(fn.body, context);
		return fn;
	};

	me.funcExpr = (fn, context) => {
		return me.func(fn, context);
	}

	me.func = (fn, context) => {
		var doIt = context => {
			fn.body.body = me.stmts(fn.body.body, context);
			return fn;
		}

		return fn.noScope ? doIt(context) : context.scope(fn, doIt);
	}

	me.comprehension = (c, context) => {
		c.filter = c.filter && me.expr(c.filter, context)
		c.blocks.forEach(b => {
			b.right = me.expr(b.right, context)
		})
		c.body = me.expr(c.body, context)
		return c;
	}

	me.monad = (m, context) => {
		m.body = me.stmt(m.body, context);
		return m;
	}

	me.conditional = (expr, context) => {
		expr.test = me.expr(expr.test, context)
    	expr.consequent = me.expr(expr.consequent, context)
    	expr.alternate = me.expr(expr.alternate, context)
    	return expr;
	}
	me.binary = (expr, context) => {
		expr.left = me.expr(expr.left, context)
    	expr.right = me.expr(expr.right, context)
    	return expr;
	}
	me.unary = (expr, context) => {
		expr.argument = me.expr(expr.argument, context)
		return expr;
	}

	me.ident = x => x;
	me.thisExpr = x => x;

	me.quasiLiteral = x => { throw new Error('Unhandled quasi literal!') };

	me.super = {};

	for ( var n in args ) {
		me.super[n] = me[n];
		me[n] = args[n]
	}

	return me;
}

module.exports = traverser;
