// # Latte JS Compiler

var 
	// A modified version of Esprima is used to parse the input
	// and produce the AST.
	esprima = require("../lib/esprima-latte"),

	// Escodegen is used to produce the output JavaScript.
	escodegen = require("escodegen"),

	transform = require("../lib/transform"),
	es = require('event-stream'),
	fs = require('fs'),
	mkdirp = require('mkdirp'),
	path = require('path'),
	glob = require("glob"),
	util = require('util');


// Streaming API
// -------------

module.exports = compiler;

// ### Single file/interactive
function compiler(options) {
	options = options || {};
	var interactive = options.interactive,
		encoding = options.encoding || 'utf8';

	// Chunks of code sent to the compiler are buffered. These
	// could be coming from a pipe, a file, or a REPL.
	var buf = [], ending = false;

	var stream = es.through (function (data) {

		// If a special EOF chunk is sent, the compiler buffer is reset.
		// *This is hacky and probably unnecessary - why not just create a new compiler?*
		if (data == compiler.EOF) {
			buf = [];
			return;
		}

		buf.push(data);

		// When in interactive mode (i.e. a REPL), try and compile after
		// each chunk (i.e. line) is recieved.
		if ( interactive ) {
			try {
				this.emit('data', compileBuffered())
			} catch (e) {
				// If compilation fails in interactive mode, just wait for more data.
				// TODO: properly detect genuine syntax errors, and reset the buffer.
			}
		}
	}, function end() {
		// At the end of the stream, compile what we have in the buffer.
		try {
			this.emit('data', compileBuffered());
		} catch (e) {
			if (!interactive) this.emit('error', e);
		}

		this.emit('end');
	});

	function compileBuffered() {
		var output = compile(buf.join(""), options);

		// After a successful compile, the buffer is reset. 
		buf = [];
		return output;
	}
	
	return stream;
}
compiler.EOF = '\u0003';


// ### Compiling a stream of files
// Takes a stream of file names/paths, separated by newlines, and compiles each.
compiler.files = function (options) {

	// Paths are relative to the current directory, and inputDir/outputDir parameters.
	var inputDir = path.join(process.cwd(), options.inputDir),
		outputDir = path.join(process.cwd(), options.outputDir);

	var stream;
	return es.pipeline(
		es.split(),
		stream = es.map(function (file, cb) {
			if (!file) return cb();

			var filePath = path.join(inputDir, file),

				// .latte file extension is replaced by .js
				output = file.replace('.latte', '.js'),

				outputPath = path.join(outputDir, output);

			mkdirp(path.dirname(outputPath), null, function (err) {
				if (err) return cb(err);

				stream.emit('data', output);

				var compiler = compileFile(filePath, options);

				compiler.on('end', function () {
					cb(null);
				});
				compiler.on('error', function (e) {
					cb(file + ': ' + e);
				});

				compiler.pipe(fs.createWriteStream(
					outputPath
				).on('error', function (e) {
					cb(file + ': ' + e);
				}));
			});
		}),
		es.join('\n')
	)
}



// Non-streaming API
// -----------------

// ### Compile a source string
function compile(source, options) {
	var ast = esprima.parse(source);

	if ( options.debug ) {
		fs.writeFileSync('ast.debug.js', util.inspect(ast, null, null));
	}

	ast = transform(ast);

	if ( options.debug ) {
		fs.writeFileSync('ast.debug.transformed.js', util.inspect(ast, null, null));
	}

	return escodegen.generate(ast, {
		comment: true
	});
}
compiler.compile = compile;

// ### Compile a file
// Returns a stream of the compiled source
function compileFile(file, options) {
	var compilerStream = compiler(options);
	return fs.createReadStream(file)
		.on('error', compilerStream.emit.bind(compilerStream, 'error'))
		.pipe(compilerStream);
}
compiler.compileFile = compileFile;

function compileFiles(files, options) {
	var fileCompiler = compiler.files(options);

	files.forEach(file => {
		fileCompiler.write(file + '\n');
	})
	fileCompiler.end();

	return fileCompiler;
}
compiler.compileFiles = compileFiles;


// ### Compile a directory of .latte files
function compileDir(inputDir, outputDir, options) {
	options.inputDir = inputDir;
	options.outputDir = outputDir;

	var fileCompiler = compiler.files(options);

	glob(inputDir + '**/*.latte', function (err, files) {
		if ( err ) {
			fileCompiler.emit('error', err);
		} else {
			files.forEach(file => {
				var name = file.slice(inputDir.length);
				fileCompiler.write(name + '\n');
			})
		}

		fileCompiler.end();
	});

	return fileCompiler;
}
compiler.compileDir = compileDir;



// Testing
// -------
// If running the module directly, start the REPL

if ( require.main == module ) {
	require("./repl")();
}
