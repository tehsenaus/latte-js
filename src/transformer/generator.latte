
var traverser = require("../traverser"),
	gen = require("../gen");

var generatorTransformer = module.exports = traverser.explicit('generator', {
	_yield: function (expr, context) {
		var oldIsInYield = context.isInYield;
		context.isInYield = true

		var bound = context.generator.yield(this.expr(expr, context));

		context.isInYield = oldIsInYield;
		return bound;
	},

	traverse: function (ast) {
		ast = this.super.traverse(ast);
		if ( ast.hasGenerators ) {
			ast['requires generator prelude'] = true;
		}
		return ast;
	},

	ifStmt: function (stmt, context) {
		var aHasYields = stmtHasYields(stmt.consequent)
			bHasYields = stmt.alternate && stmtHasYields(stmt.alternate);

		if ( aHasYields || bHasYields ) {

			// There are yields in our branches. Save the current
			// continuation, and call it with the result of the
			// branch we take.

			context.generator.withcc((cc) => {

				return gen.ifStmt(
					stmt.test, [
						this.stmt(stmt.consequent, context),
						cc( gen.ident('null') )
					], [
						stmt.alternate ? this.stmt(stmt.alternate, context) : gen.empty,
						cc( gen.ident('null') )
					]
				);

			});

			return gen.empty;
		}

		// Doesn't contain yields, but may contain other generators
		var oldGenerator = context.generator;
		context.generator = null;
		
		stmt = this.super.ifStmt(stmt, context);
		
		context.generator = oldGenerator;

		return stmt;
	},

	forInOfStmt: function (stmt, context) {

		if ( !stmt.generatoric && stmtHasYields(stmt.body) ) {
			throw new Error('Yields not supported in for statement... yet!');
		}

		// Doesn't contain yields, but may contain other generators
		var oldGenerator = context.generator;
		context.generator = null;
		
		stmt = this.super.forInOfStmt(stmt, context);
		
		context.generator = oldGenerator;

		return stmt;
	},

	forStmt: function (stmt, context) {
		if ( !stmt.generatoric && stmtHasYields(stmt.body) ) {

			throw new Error('Yields not supported in for statement... yet!');

			
		}

		// Doesn't contain binds, but may contain other monads
		var old = context.generator;
		context.generator = null;
		
		stmt = this.super.forStmt(stmt, context);
		
		context.generator = old;

		return stmt;
	},

	whileDoWhileStmt: function (stmt, context) {
		if ( context.generator && stmtHasYields(stmt.body) ) {

			// Body contains binds. Convert to a recursive
			// closure
			
			var rec = context.temp();

			if ( stmt.type == 'DoWhileStatement' ) {
				stmt = gen.block(stmt.body).body.concat([
					// Do test, if pass, recurse
					gen.ifStmt( stmt.test, gen.ret(gen.call(rec)) )
				]);
			} else {
				stmt = [
					// Do test, if pass, evaluate body and recurse
					gen.ifStmt(stmt.test, gen.block(stmt.body).body.concat([
						gen.ret( gen.call(rec) )
					]))
				];
			}

			stmt = gen.closure(stmt, [], rec);
			stmt.callee.generator = true;
			stmt.callee.internalGenerator = context.generator;

			return gen.block(this.stmts([
				gen.exprStmt( stmt )
			], context));
		}

		// Doesn't contain yields, but may contain other generators
		var oldMonad = context.monad;
		context.generator = null;
		
		stmt = this.super.whileDoWhileStmt(stmt, context);
		
		context.generator = oldMonad;

		return stmt;
	},

	switchStmt: function (stmt, context) {
		if ( stmtHasYields(stmt) ) {
			throw new Error('Yields not supported in switch statement... yet!');
		}

		// Doesn't contain binds, but may contain other monads
		var old = context.generator;
		context.generator = null;
		
		stmt = this.super.switchStmt(stmt, context);
		
		context.generator = old;

		return stmt;
	},
	tryStmt: function (stmt, context) {
		if ( stmtHasYields(stmt) ) {
			throw new Error('Yields not supported in try statement... yet!');
		}

		// Doesn't contain binds, but may contain other monads
		var old = context.generator;
		context.generator = null;
		
		stmt = this.super.tryStmt(stmt, context);
		
		context.generator = old;

		return stmt;
	},

	func: function (stmt, context) {
		// if (stmt.generatoric) {
		// 	var body = this.withGenerator(stmt, context, () => {
		// 		return this.super.func(stmt, context);
		// 	});

		// 	stmt.body = gen.block(body);

		// 	return stmt;
		// }
		
		// Inner functions have new context
		var oldGenerator = context.generator;
		context.generator = null;

		stmt = this.super.func(stmt, context);
		
		context.generator = oldGenerator;
			
		return stmt;
	},

	yieldExpr: function (expr, context) {
		if (!context.generator) {
			throw new Error('Unexpected yield: not in generator!');
		}

		return this._yield(expr.argument, context);
	},

	binary: function (expr, context) {
		// Support short circuit evaluation
		if ( !context.isInYield && expr.type === 'LogicalExpression') {
			var bHasYields = exprHasYields(expr.right);

			if ( bHasYields ) {
				
				var test = gen.ident(context.temp());
				this.stmt( gen.varDecl(test, expr.left), context );

				return context.generator.withcc((cc) => {

					return gen.ifStmt(
						expr.operator == '||' ? gen.not(test) : test, [
							cc( this.expr(expr.right, context) )
						], [
							cc( test )
						]
					);

				});

			}
		}

		return this.super.binary(expr, context);
	},

	conditional: function (expr, context) {
		if ( !context.isInYield ) {
			var aHasYields = exprHasYields(expr.consequent)
				bHasYields = exprHasYields(expr.alternate);

			if ( aHasYields || bHasYields ) {

				// There are yields in our branches. Save the current
				// continuation, and call it with the result of the
				// branch we take.

				return context.generator.withcc((cc) => {

					return gen.ifStmt(
						expr.test, [
							cc( this.expr(expr.consequent, context) )
						], [
							cc( this.expr(expr.alternate, context) )
						]
					);

				});

				
			}
		}

		return this.super.conditional(expr, context);
	},


	callExpr: function (expr, context) {
		if ( expr.callee.generator && expr.callee.internalGenerator
			&& expr.callee.body.body[0].type == 'ReturnStatement' ) {

			var m = expr.callee;

			return m.internalGenerator.withcc(cc => {

				// Call the current continuation with the value of the
				// generator expression.
				m.body = cc( expr.callee.body.body[0].argument );

				expr = this.super.callExpr(expr, context);

				//console.log('callExpr', m.body.body.map(dbg));

				return gen.exprStmt(expr);
			});
		}

		return this.super.callExpr(expr, context);
	},

	stmt: function (stmt, context) {

		if ( stmt.type == 'ExpressionStatement' ) {

			// Yield statement - not using value, so avoid adding
			// useless expressionstmt
			if ( stmt.expression.type == 'YieldExpression' ) {
				return this.super.stmt(stmt, context);
			}

			// Calling an internal generator
			if ( stmt.expression.type == 'CallExpression'
					&& stmt.expression.callee.generator
					&& stmt.expression.callee.internalGenerator ) {

				var m = stmt.expression.callee;

				m.internalGenerator.withcc(cc => {
					// Call our continuation at end of internal generator
					m.body.body.push(cc());

					stmt.expression.callee = this.expr(stmt.expression.callee, context);

					return gen.ret(stmt.expression);
				});

				return gen.empty;
			}
		}
				

		stmt = this.super.stmt(stmt, context);

		if ( context.generator ) {
			if ( stmt.type != 'BlockStatement' ) {
				context.generator.stmt(stmt);
				stmt = gen.empty;
			}
		}

		return stmt;
	},



	withGenerator: function (m, context, fn) {
		var lastGenerator = context.generator;
		var yields = [],
			stmts = [],
			continuations = [],
			body = [],
			topLevelBody = body;

		var generator = context.generator = {

			// signals that the next block of statements needs to be
			// extracted as a named continuation (i.e. if there are branches
			// which need to merge).
			//
			// The value of the current expression (if applicable)
			// is passed as 'ccv'. This is a parameter to the continuation.
			withcc: (fn) => {
				var pre = stmts,
					preYields = yields,
					cc = context.temp(),
					ccv = context.temp();

				yields = []; stmts = [];

				stmt = fn((v) => generator.callc(cc, v));

				yields = preYields; stmts = pre;
				generator.stmt(stmt);

				var r = generator.callc(gen.block([]));
				body.push(r);

				var continuation = gen.fndecl(
					[], [ccv], cc
				);
				body = continuation.body.body;
				stmts = [];
				continuations.push(continuation);

				return gen.ident(ccv);
			},

			// Evaluate yields in sequence, then call the passed continuation
			// with the specified value expression
			callc: (c, v) => {
				var r = c.type == 'BlockStatement' ? c : gen.call(c, v ? [v] : []);

				// Anything else to do before we call?
				if ( stmts.length ) {
					if ( r.type == 'CallExpression' ) {
						r = gen.block([ gen.ret(r) ])
					}

					r.body = stmts.concat(r.body);
					stmts = [];
				}

				r = yields.reduceRight(
					(s, y) => gen.block( y.stmts.concat([

						gen.ret(gen.call(YIELD, [
							y.expr, gen.arrow([y.e, y.t], s)
						]))
					]) ),
					
					r
				)

				yields = [];

				return r.type == 'CallExpression' ? gen.block([gen.ret(r)]) : r;
			},

			yield: (expr) => {
				var e = 'e', //context.temp(),
					t = context.temp();

				yields.push({
					e: e, t: t,
					expr: expr,
					stmts: stmts
				});
				stmts = [];
				cc = null;
				return gen.ident(t);
			},

			stmt: stmt => stmts.push(stmt)
		}

		// Traverse
		m = fn();

		context.generator = lastGenerator;
		context.ast.hasGenerators = true;

		body.push(generator.callc(gen.block([])));
		return gen.block( topLevelBody.concat(continuations) );
	},

	generator: function (m, context) {

		if ( m.internalGenerator ) {
			
			m.body = this.withGenerator(m, context, () => {
				return this.super.generator(m, context);
			});

		} else {

			m.body.body.push(gen.exprStmt(gen.call('__stop')));

			var body = this.withGenerator(m, context, () => {
				// Traverse to get all yields
				return this.super.generator(m, context);
			})

			m.body.body = [ gen.ret(
				gen.call('__gen', [ gen.fn([
					body.type.indexOf('Expression') > 0 ? gen.ret(body) : body
				], ['__yield','__stop']) ]) 
			)];
		}

		m.generator = false;

		return m;
	}
})


var hasYieldsTraverser = traverser({
	exprHasYields: function (expr) {
		var context = this.context();
		this.expr(expr, context);
		return context.hasYields;
	},

	stmtHasYields: function (stmt) {
		var context = this.context();
		this.stmt(stmt, context);
		return context.hasYields;
	},

	yieldExpr: function (e, context) {
		context.hasYields = true;
		return this.super.yieldExpr(e, context);
	},

	generator: function (g) {
		// We stop here: yields are local
		return g;
	}
});
function exprHasYields(expr) {
	return hasYieldsTraverser.exprHasYields(expr);
}
function stmtHasYields(stmt) {
	return hasYieldsTraverser.stmtHasYields(stmt);
}

function genYield(expr) {
	return {
		type: 'YieldExpression',
		argument: expr
	}
}
function genGenerator(stmts) {
	return gen.call({
		type: 'FunctionExpression',
		params: [],
        defaults: [],
		body: gen.block( stmts ),
		generator: true
	})
}
function genGeneratorExpr(expr, context) {
	var r = gen.closure([ gen.ret(expr) ]);
	r.callee.generator = true;
	r.callee.internalGenerator = context.generator;
	return r;
}


var YIELD = '__yield';

function dbg(v) {
	try {
		return require("escodegen").generate(v);
	} catch (e) {
		return v;
	}
}
