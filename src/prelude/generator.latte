// # Generator Prelude

function __Generator(me, fn) {
	this.me = me;
	this.fn = fn;
	this.born = false;
	this.closed = false;
}
function __generatorYield(me, v, next) {
	me.fn = next;
	return new __IteratorValue(v, false);
}
function __generatorStop(me, v) {
	me.closed = true;
	return v === (void 0) ? __IteratorValue.done : new __IteratorValue(v, true);
}

__Generator.prototype = {
	// Generators implement the iterator protocol, and they are
	// 'one-shot' iterators.
	iterator: function () {
		return this;
	},
	
	next: function () {
		return this.send();
	},
	send: function (v) {
		if ( this.closed )
			throw new Error('generator is closed!');

		if ( !this.born ) {
			this.born = true;
			return this.fn.call(this.me, this);
		}
		if ( !this.fn ) {
			me.closed = true;
			return __IteratorValue.done;
		}

		return this.fn.call(this.me, null, v);
	},

	"throw": function (e) {
		if ( this.closed )
			throw new Error('generator is closed!');

		if ( !this.born ) {
			throw e;
		}

		return this.fn.call(this.me, e);
	}
}

function __gen(me, fn) {
	return new __Generator(me, fn);
}
