
var traverser = require("./traverser");

var insertLexicalThisTransformer = traverser({
	func: (fn, context) => {
		if (!fn.noScope) fn.body.body.splice(0, 0, SET_LEXICAL_THIS);
		return insertLexicalThisTransformer.super.func(fn, context);
	}
})
var replaceThisTransformer = traverser({
	func: fn => fn,
	thisExpr: (ident, context) => {
		return {
			type: 'Identifier',
			name: context && context.lexicalThis || LEXICAL_THIS
		}
	}
});

var arrowTransformer = traverser({
	arrowFuncExpr: (fn) => {
		return arrowTransformer.funcExpr({
			"type": "FunctionExpression",
	        "id": null,
	        "params": fn.params,
	        "defaults": [],
	        "body": fn.body.type == 'BlockStatement' ? replaceThisTransformer.stmt(fn.body) : {
	            "type": "BlockStatement",
	            "body": [
	                {
	                    "type": "ReturnStatement",
	                    "argument": replaceThisTransformer.expr(fn.body)
	                }
	            ]
	        },
	        "rest": null,
	        "generator": false,
	        "expression": false,
	        noScope: true
		})
	}
})

function makeLiteral(value, raw) {
	return {
        "type": "Literal",
        "value": value,
        "raw": raw
    }
}
function makeDefaultQuasi(literals, exprs) {
	var elems = [], i = 0;
	while (i < literals.length - 1) {
      elems.push(makeLiteral(literals[i].value.cooked, literals[i].value.raw));
      elems.push(exprs[i++]);
    }
    elems.push(makeLiteral(literals[i].value.cooked, literals[i].value.raw));

	return {
	    "type": "CallExpression",
	    "callee": {
	        "type": "MemberExpression",
	        "computed": false,
	        "object": {
	            "type": "ArrayExpression",
	            "elements": elems
	        },
	        "property": {
	            "type": "Identifier",
	            "name": "join"
	        }
	    },
	    "arguments": [
	        {
	            "type": "Literal",
	            "value": "",
	            "raw": "''"
	        }
	    ]
	}
}
var quasiTransformer = traverser({
	quasiLiteral: (q, context) => {
		return makeDefaultQuasi(q.quasis, q.expressions.map(e => quasiTransformer.expr(e)));
	}
})


var 
LEXICAL_THIS = '__this',
SET_LEXICAL_THIS = {
    "type": "VariableDeclaration",
    "declarations": [
        {
            "type": "VariableDeclarator",
            "id": {
                "type": "Identifier",
                "name": LEXICAL_THIS
            },
            "init": {
                "type": "ThisExpression"
            }
        }
    ],
    "kind": "var"
};


var transformers = [
	quasiTransformer,
	arrowTransformer,
	insertLexicalThisTransformer
]

module.exports = function (ast) {

	ast = transformers.reduce((ast, t) => t.traverse(ast), ast);

	ast.body.splice(0,0, SET_LEXICAL_THIS);

	return ast;
};
