
var traverser = require("./traverser"),
	gen = require("./gen");

var insertLexicalThisTransformer = traverser({
	func: (fn, context) => {
		if (!fn.noScope) fn.body.body.splice(0, 0, SET_LEXICAL_THIS);
		return insertLexicalThisTransformer.super.func(fn, context);
	}
})
var replaceThisTransformer = traverser({
	func: fn => fn,
	thisExpr: (ident, context) => {
		return {
			type: 'Identifier',
			name: context && context.lexicalThis || LEXICAL_THIS
		}
	}
});

var arrowTransformer = traverser({
	arrowFuncExpr: (fn, context) => {
		return arrowTransformer.funcExpr({
			"type": "FunctionExpression",
	        "id": null,
	        "params": fn.params,
	        "defaults": [],
	        "body": fn.body.type == 'BlockStatement' ? replaceThisTransformer.stmt(fn.body, context) : {
	            "type": "BlockStatement",
	            "body": [
	                {
	                    "type": "ReturnStatement",
	                    "argument": replaceThisTransformer.expr(fn.body, context)
	                }
	            ]
	        },
	        "rest": null,
	        "generator": false,
	        "expression": false,
	        noScope: true
		}, context)
	}
})

function makeLiteral(value, raw) {
	return {
        "type": "Literal",
        "value": value,
        "raw": raw
    }
}
function makeDefaultQuasi(literals, exprs) {
	var elems = [], i = 0;
	while (i < literals.length - 1) {
      elems.push(makeLiteral(literals[i].value.cooked, literals[i].value.raw));
      elems.push(exprs[i++]);
    }
    elems.push(makeLiteral(literals[i].value.cooked, literals[i].value.raw));

	return {
	    "type": "CallExpression",
	    "callee": {
	        "type": "MemberExpression",
	        "computed": false,
	        "object": {
	            "type": "ArrayExpression",
	            "elements": elems
	        },
	        "property": {
	            "type": "Identifier",
	            "name": "join"
	        }
	    },
	    "arguments": [
	        {
	            "type": "Literal",
	            "value": "",
	            "raw": "''"
	        }
	    ]
	}
}
var quasiTransformer = traverser({
	quasiLiteral: (q, context) => {
		return makeDefaultQuasi(q.quasis, q.expressions.map(e => quasiTransformer.expr(e)));
	}
})



var arrayDestructuringTransformer = traverser({
	decl: function (d, context) {
		d = this.super.decl(d, context);
		if ( d.id.type != 'ArrayPattern' ) {
			return d;
		}

		// Transform into array of decls. This will be flattened into one
		// declaration.
		var temp = {
            "type": "Identifier",
            "name": '__destructure'
        };
		return [
			// Store rhs into temp
			gen.decl(temp, d.init)
		].concat(d.id.elements.map(
			(e, i) => this.decl( gen.decl(e, gen.member(temp, i, { computed: true })) )
		));
	}
})


var letTransformer = traverser({
	varDecl: function (d, context) {
		d = this.super.varDecl(d, context);

		if ( d.kind == 'let' ) {
			d.kind = 'var';
			context.blocks[0].node.requiresBlockScope = true;
		}

		return d;
	},

	forInStmt: function (stmt, context) {
		if ( stmt.left.type == 'VariableDeclaration' && stmt.left.kind == 'let' ) {
			var body = stmt.body;
			if ( body.type !== 'BlockStatement' ) {
				body = stmt.body = gen.block([ body ]);
			}

			// stmt.left.kind = 'var';
			// body.requiresBlockScope = true;
			// body.blockScopeParams = stmt.left.declarations.map(d => d.id);

			// Change to Object.keys.forEach
			return this.stmt(gen.forEachKey(
				stmt.right,
				body.body,
				stmt.left.declarations[0].id
			), context)
		}

		return this.super.forInStmt(stmt, context);
	},
	block: function (b, context) {
		var block = this.super.block(b, context);

		if ( b.requiresBlockScope ) {
			b.body = [ {
            	"type": "ExpressionStatement",
            	"expression": gen.closure(b.body, b.blockScopeParams) 
           	}]
		}

		return b;
	}
});

var comprehensionTransformer = traverser({
	comprehension: function (c, context) {
		var body = {
            "type": "ExpressionStatement",
            "expression": gen.call(
				gen.member('__comp', 'push'), [
					c.body
				]
			)
        };

        if ( c.filter ) {
        	body = {
	            "type": "IfStatement",
	            "test": c.filter,
	            "consequent": body
	        }
        }

        c.blocks.reverse().forEach(b => {
        	body = {
	            "type": "ForInStatement",
	            "left": {
	                "type": "VariableDeclaration",
	                "declarations": [
	                    {
	                        "type": "VariableDeclarator",
	                        "id": b.left,
	                        "init": null
	                    }
	                ],
	                "kind": "var"
	            },
	            "right": b.right,
	            "body": body,
	            "each": false
	        }
        });

		return this.expr(gen.closure([
			gen.varDecl('__comp', {
                "type": "ArrayExpression",
                "elements": []
            }),
			body,
			{
                "type": "ReturnStatement",
                "argument": gen.ident('__comp')
            }
		]));
	}
});


var forFilterTransformer = traverser({

	forInStmt: function (stmt, context) {
		if ( stmt.filter ) {
			stmt.body = gen.block([ {
	            "type": "IfStatement",
	            "test": stmt.filter,
	            "consequent": stmt.body
	        } ])
	        stmt.filter = null;
		}

		return this.super.forInStmt(stmt, context);
	}
});


var 
LEXICAL_THIS = '__this',
SET_LEXICAL_THIS = {
    "type": "VariableDeclaration",
    "declarations": [
    	gen.decl(LEXICAL_THIS, { "type": "ThisExpression" })
    ],
    "kind": "var"
};


var transformers = [
	quasiTransformer,
	comprehensionTransformer,
	arrowTransformer,
	arrayDestructuringTransformer,
	forFilterTransformer,
	letTransformer,
	insertLexicalThisTransformer
]

module.exports = function (ast) {

	ast = transformers.reduce((ast, t) => t.traverse(ast), ast);

	ast.body.splice(0,0, SET_LEXICAL_THIS);

	return ast;
};
